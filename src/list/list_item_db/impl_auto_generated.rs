use super::interface::ListItemDb;
use crate::{
    core::{
        pagination::Paginated,
        query::{Query, QueryFilter, QueryOp},
    },
    list::{
        list::List,
        list_db::interface::{ListDb, ListQueryField},
        list_id::ListId,
        list_item::ListItem,
    },
    media::interaction::{
        interaction_db::interface::MediaInteractionDb, interaction_name::InteractionName,
    },
};
use async_trait::async_trait;
use std::sync::Arc;

pub struct ImplAutoGenerated {
    media_interaction_db: Arc<dyn MediaInteractionDb>,
    list_db: Arc<dyn ListDb>,
}

impl ImplAutoGenerated {
    #[allow(dead_code)]
    pub fn new(
        media_interaction_db: Arc<dyn MediaInteractionDb>,
        list_db: Arc<dyn ListDb>,
    ) -> Self {
        Self {
            media_interaction_db,
            list_db,
        }
    }
}

#[async_trait]
impl ListItemDb for ImplAutoGenerated {
    async fn find_by_list_id(
        &self,
        limit: usize,
        offset: usize,
        list_id: ListId,
    ) -> Result<Paginated<ListItem>, std::io::Error> {
        let maybe_list = self
            .list_db
            .query(Query {
                limit: limit.clone(),
                offset: offset.clone(),
                filter: QueryFilter::Clause(
                    ListQueryField::ListId,
                    QueryOp::Eq,
                    list_id.as_str().to_string(),
                ),
            })
            .await?
            .items
            .first()
            .map(|v| v.to_owned());

        let empty_response = Ok(Paginated {
            items: vec![],
            total: 0,
            limit,
            offset,
        });

        let (list, interaction_name) = match maybe_list {
            Some(_list) => (List::default(), InteractionName::random()),
            None => {
                return empty_response;
            }
        };

        let interactions = self
            .media_interaction_db
            .find_by_user_id_and_interaction_name(&list.creator_user_id, &interaction_name)
            .await?;

        let list_items: Vec<ListItem> = interactions
            .iter()
            .map(|i| ListItem::from((list.id.clone(), i.clone())))
            .collect();

        let total = list_items.len();

        let items = list_items
            .iter()
            .skip(offset)
            .take(limit)
            .cloned()
            .collect();

        Ok(Paginated {
            total,
            items,
            limit,
            offset,
        })
    }
}
