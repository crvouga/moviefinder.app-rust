#[cfg(test)]
mod tests {
    use std::sync::Arc;

    use crate::{
        core::{
            query::{Query, QueryFilter, QueryOp},
            unit_of_work::UnitOfWork,
        },
        fixture::BaseFixture,
        list::{
            core::{list::ListVariant, list_item::ListItem},
            list_db::{
                self,
                interface::{ListDb, ListQueryField},
            },
            list_item_db::{
                impl_auto_generated::ImplAutoGenerated,
                interface::{ListItemDb, ListItemQueryField},
            },
        },
        media::interaction::{
            interaction_::MediaInteraction, interaction_db::interface::MediaInteractionDb,
            interaction_name::InteractionName,
        },
        user::user_id::UserId,
    };

    struct Fixture {
        interaction_db: Arc<dyn MediaInteractionDb>,
        list_db: Arc<dyn ListDb>,
        list_item_db: Arc<dyn ListItemDb>,
    }

    impl Fixture {
        pub async fn add_interactions(
            &self,
            uow: UnitOfWork,
            interaction_name: InteractionName,
            user_id: UserId,
            count: usize,
        ) -> Vec<MediaInteraction> {
            let mut interactions = vec![];
            for _ in 0..count {
                let interaction = self
                    .add_interaction(uow.clone(), interaction_name.to_owned(), user_id.to_owned())
                    .await;

                interactions.push(interaction);
            }
            interactions
        }

        pub async fn add_interaction(
            &self,
            uow: UnitOfWork,
            interaction_name: InteractionName,
            user_id: UserId,
        ) -> MediaInteraction {
            let i = MediaInteraction {
                interaction_name,
                user_id,
                ..MediaInteraction::random()
            };

            self.interaction_db.put(uow, &i).await.unwrap();

            i
        }
    }

    async fn fixtures() -> Vec<Fixture> {
        let mut fixtures: Vec<Fixture> = vec![];

        let base = BaseFixture::new().await;

        let interaction_db = base.ctx.media_interaction_db;

        fixtures.push(Fixture {
            interaction_db: interaction_db.clone(),
            list_db: Arc::new(list_db::impl_auto_generated::ImplAutoGenerated::new(
                interaction_db.clone(),
            )),
            list_item_db: Arc::new(ImplAutoGenerated::new(interaction_db.clone())),
        });

        fixtures
    }

    #[tokio::test]
    async fn test_it_should_work() {
        for f in fixtures().await {
            let user_id = UserId::default();
            let uow = UnitOfWork::new();
            let interactions = f
                .add_interactions(uow, InteractionName::Liked, user_id.clone(), 3)
                .await;

            let lists = f
                .list_db
                .query(Query {
                    limit: 10,
                    offset: 0,
                    filter: QueryFilter::Clause(
                        ListQueryField::UserId,
                        QueryOp::Eq,
                        user_id.as_str().to_string(),
                    ),
                })
                .await
                .unwrap()
                .items;

            let list = lists
                .into_iter()
                .find(|l| {
                    matches!(
                        l.variant,
                        ListVariant::AutoGenerated(InteractionName::Liked),
                    )
                })
                .unwrap();

            let mut expected: Vec<ListItem> = interactions
                .iter()
                .map(|i| ListItem::from((list.id.clone(), i.clone())))
                .collect();

            let mut actual = f
                .list_item_db
                .query(Query {
                    limit: 10,
                    offset: 0,
                    filter: QueryFilter::Clause(
                        ListItemQueryField::ParentListId,
                        QueryOp::Eq,
                        list.id.as_str().to_string(),
                    ),
                })
                .await
                .unwrap()
                .items;

            expected.sort_by_key(|l| l.created_at_posix);
            actual.sort_by_key(|l| l.created_at_posix);
            assert_eq!(expected, actual);
        }
    }
}
